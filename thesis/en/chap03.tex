\chapter{Developer's Documentation}

In this chapter, we will examine the structure of our game and the implementation of its
various modules. In Figure~\ref{engine-layout}, we can see the main modules of our engine
and their relationships -- an arrow pointing from module A to module B means that A uses B.

\begin{figure}[h]
    \centering
    \fontfamily{fi4}\selectfont
    \def\svgwidth{\columnwidth}
    \input{engine.pdf_tex}
    \caption{Core of the game's engine.}
    \label{engine-layout}
\end{figure}

The game uses four different libraries -- Ogre3D for graphics, OIS\footnote{Bundled with Ogre3D.} for user input, CEGUI for
GUI and Lua for scripting. Ogre3D and OIS are used directly by the engine, but CEGUI and Lua -- besides initialization in the
\texttt{Game} class -- use special interface modules that handle their API. The GUI module, which acts as an interface
for CEGUI, comprises the \texttt{GUI} class and various different classes that represent different GUI widgets. Lua uses different
classes for the different directions of access. When the engine -- written in C++ -- accesses Lua, it uses the \texttt{lpp::Script} class,
which acts as a wrapper facade over the Lua C API. When Lua accesses parts of the engine, it uses the \texttt{LuaInterface} class,
which binds functions written in C++ to Lua.

The update logic of the game is performed by systems which, with the exception of \texttt{EntitySystem}, are equal in functionality.
\texttt{EntitySystem} stands out because it, besides updating the game, aslo acts as a component manager and provides components
to the rest of the systems.

In the following sections we will examine these main modules of the engine as well as various other, which mostly serve as tools
to the main modules.

\section{Game}

The \texttt{Game} class is the central part of our engine. In its constructor, every module of the engine -- that needs initialization --
is initialized. This class also serves as the main connection between the Ogre3D and OIS libraries and our engine.It does so by inheriting
four listener classes from these libraries -- \texttt{Ogre::FrameListener}, \texttt{Ogre::WindowEventListener}, \texttt{OIS::KeyListener}
and \texttt{OIS::MouseListener}.

\begin{listing}
    \centering
    \begin{lstlisting}[language=C++]
// Ogre3D
bool frameRenderingQueued(const Ogre::FrameEvent&);
void windowResized(Ogre::RenderWindow*);
void windowClosed(Ogre::RenderWindow*)

// OIS
bool keyPressed(const OIS::KeyEvent&);
bool keyReleased(const OIS::KeyEvent&);
bool mouseMoved(const OIS::MouseEvent&);
bool mousePressed(const OIS::MouseEvent&,
                  OIS::MouseButtonID);
bool mouseReleased(const OIS::MouseEvent&,
                   OIS::MouseButtonID);
    \end{lstlisting}
    \caption{Virtual functions overriden in the \texttt{Game} class.}
    \label{ois-ogre-callbacks}
\end{listing}

Communication between the game and these two libraries is done, besides using their API, by overriding virtual functions of these classes
which act as event handlers. We can see these functions in Listing~\ref{ois-ogre-callbacks}. While names of most of these functions are
self-explanatory -- and their documentation can be found in the Ogre3D and OIS documentations -- we will examine the functionality of
\texttt{frameRenderingQueued} in a bit more depth.

\texttt{Ogre::FrameListener} provides three virtual functions -- \texttt{frameStarted}, which is called when a frame
is about to begin rendering, \texttt{frameEnded}, which is called when a frame has just been rendered, and \texttt{frameRenderingQueued},
which gets called when all rendering commands have been issued and are queued for the GPU to process. In our \texttt{Game} class, we override
only this last function -- although others can be overriden for different actions as well -- because while the GPU processes the current
frame, the CPU can be used for different tasks -- such as our update loop. This means that any changes that happen inside this function
will be rendered on the next frame, but in our game this delay is not noticeable as the player does not directly control any one entity.
We use this function to perform the main functionality of our game -- performing game update by calling the update functions of all
systems that are in the game.

Besides handling input and window events, this class contains several auxiliary functions related to initialization, level creation and
state changing. To see more information about these functions, refer to their documenting comments in the header file or in the
generated documentation.

\section{Components}

Component is a data aggregate that describes a specific characteristic of an entity that contains the component. In our engine, these
components are represented as simple structures with a name in the form of \texttt{<Characteristic>Component}. 

\begin{listing}
    \centering
    \begin{lstlisting}[language=C++]
struct MovementComponent
{
    static constexpr int type = 4;

    MovementComponent(tdt::real speed = 0.f)
        : speed_modifier{speed}, original_speed{speed}
    { /* DUMMY BODY */ }

    tdt::real speed_modifier;
    tdt::real original_speed;
}
    \end{lstlisting}
    \caption{Simplified representation of the MovementComponent structure.}
    \label{component-ex}
\end{listing}

In Listing~\ref{component-ex}, we can see an example of a component -- the MovementComponent, which describes the speed of an entity.
Every component has a static integer field representing its type, which is used for communication between Lua and C++ because Lua does not
understand the notion of templates, which we use for the different functions that manipulate with components, and as such it needs
to specify what kind of component should be used when it calls a C++ function.

There is only one other requirement for components, which is that they always need to have a parameterless constructor
\footnote{A constructor that has default values for all its parameters will suffice.}. This is required because
we often create components by calling a C++ function in Lua and then set its fields, which would be impossible without a constructor that
doesn't need any parameters. Also note that because of this approach, any strings passed to any parameterized constructor are considered
to be passed from Lua and as such are \textbf{moved} because the originals are supposed to be destroyed by Lua once the creation is complete.

Besides the two requirements, components can contain any data required by the entity characteristic they describe. In the examle, the
MovementComponent contains two fields of type \texttt{tdt::real}\footnote{One of two numeric types used in the engine, the other being
tdt::uint.}
-- speed\_modifier, which indicates the speed of an entity, and original\_speed, which is used
to restore the speed of an entity that has been affected by a slowing effect. Note that, to conform our
ECS representation, components should not contain functions and any logic should be done through systems.

\section{Systems}

A system is a class that performs a part of the games update. The game provides a common abstract parent class \texttt{System}, which is
used for easy iteration over all systems during the update of the game. In general, a system should operate over one or more types of
components, but the creation of systems that do not use components is also possible.

The update function of every system is called once per frame, but the individual systems often have inner time periods between updates.

\subsection{EntitySystem}

\texttt{EntitySystem} is the main system as, besides performing part of the game's update, it acts as a component database. This means that
it stores all component containers, which are represented as \texttt{std::map<entity\_id, component>}. Besides storing the components,
it also provides a set of function templates used for component manipulation.

\begin{listing}
    \centering
    \begin{lstlisting}[language=C++]
template<typename COMP>
bool has_component(tdt::uint id);

template<typename COMP>
COMP* get_component(tdt::uint id);

template<typename COMP>
void add_component(tdt::uint id);

template<typename COMP>
void delete_component(tdt::uint id);
    \end{lstlisting}
    \caption{Examples of the templates using for component manipulation.}
    \label{es-comp-manip-ex}
\end{listing}

Some of these function templates can be seen in Listing~\ref{es-comp-manip-ex}. They can be used to test if an entity has a component,
to retrieve a component
that belongs to an entity, add a new component -- using the parameterless constructor -- to an entity and remove a component from an entity,
respectively. In addition to these templates, each of them has a secondary non-templated version which takes an integer as a second parameter,
which corresponds to the type of the component -- these functions are then used from Lua.
To prevent code repetition, these functions use an array of pointers to the templated versions in which the pointer at any given index points
to the instances of these templated functions that have their type field equal to the index number.

In addition to these public templates, one more important private template is defined in \texttt{EntitySystem} -- \texttt{load\_component}.
This function template accepts the identifier of an entity along with a name of a Lua table, which it will then use to load a component
with fields specified by the provided table.

Besides component storage and manipulation, this class also serves as a system. During its update, it deletes all components and entities
that were scheduled for deletion by the function \texttt{delete\_component}. The reason for this delayed delete is that if we deleted
components from their containers immediately in the delete call, we might invalidate iterators as the call may very well happend during
an iteration over a component container.

\subsection{CombatSystem}

The \texttt{CombatSystem} class performs the update of basic combat between entities -- that is, melee
\footnote{By melee we refer to close range combat as is common in many games.} and ranged combat excluding spells.
During its update, it checks the ability to attack of all entities that currently have an active combat target. This includes checking
if the target is in sight and in range. If an entity can attack, the system either performs applies its damage to its target if the
attack is of the melee type or creates a new projectile if the attack is of type ranged.
After updating the combat state of all entities that are currently fighting, the system updates the movement of all projectiles.

This system also performs a special kind of pathfinding which is used to find a path for an entity that is trying to escape from an attacker.
This pathfinding, unlike the general pathfinding that finds a path to the target, uses a queue and is performed once per frame. The reason for
this is that this pathfinding does not need to be performed immediately, while the general pathfinding is often used to check for the
existence of a path and as such needs to be finnished right after its start so that the return value can be used.

In addition to performing part of the game's update, \texttt{CombatSystem} provides two important types of functions -- querying for closest
entity that satisfies a condition, applying an effect to all entities in range that satisfy a condition.

\subsubsection{Conditions and entity querying}

Conditions are functors -- that is, structures that overload the function call operator -- which are used to test if an entity satisfies
a certain requirement. \texttt{CombatSystem} provides a function template that can be used to find the closest entity that satisfies
a condition.

\begin{listing}
    \centering
    \begin{lstlisting}[language=C++]
template<typename CONT, typename COND>
tdt::uint get_closest_entity(tdt::uint, COND&, bool);
    \end{lstlisting}
    \caption{Signature of the entity query function template.}
    \label{cond-ex}
\end{listing}

In Listing~\ref{cond-ex}, we can see the signature of this function template. Its template parameters are \texttt{CONT}, which specifies
the type of component container the function will be querying over, and \texttt{COND}, which specifies the condition functor. The function
takes the identifier of the entity that performs the query, instance of the condition functor and a boolean value determining if the
target has to be in sight and returns the identifier of the closest entity that satisfies the condition.

\subsubsection{Effects and their application}

In addition to entity querying, \texttt{CombatSystem} provides a function template that allows us to apply an effect to all entities
that satisfy a condition and are withing range. An effect, similarly to a condition, is a functor which is used to affect the entity
it is used on.

\begin{listing}
    \centering
    \begin{lstlisting}[language=C++]
template<typename CONT, typename COND, typename EFFECT>
void apply_effect_to_entities_in_range(tdt::uint, COND&,
                                       EFFECT&, tdt::real);
    \end{lstlisting}
    \caption{Signature of the effect applying function template.}
    \label{effect-ex}
\end{listing}

The signature of this function template can be seen in Listing~\ref{cond-ex}. Its template parameters are the same as the ones used
in entity querying with the addition of the parameter \texttt{EFFECT}, which specifies the effect functor. The function takes the
identifier of the entity that applies the effect, the condition the targets need to satisfy, the effect that will be applied to the
targets and the maximal range the targets can be from the applying entity.

\subsection{EventSystem}

\texttt{EventSystem} manages event handling as part of the game update. To do this, it uses two different components --
\texttt{EventComponent}, which represents an event, and \texttt{EventHandlerComponent}, which represents the ability of an entity
to handle events.

During its update, this system iterates over all events in the game and, if they are active -- finds a suitable entity that will
handle the event. Events can be of two types, either targeted or area events. An event is targeted if it has a valid entity
identifier in its \texttt{handler} field, otherwise it is an area event.

To request an entity to handle an event, the system checks if the entity can handle it by testing the event type in the entity's
\texttt{possible\_events} bitset field. Every \texttt{EventHandlerComponent} has a string field \texttt{handler}, which specifies
which Lua table contains the event handling function called \texttt{handle\_event}. The system then calls this event handling
function and passes the identifier of the handling entity and the identifier of the event to it, which causes the entity
to handle the event.

To handle a targeted event, the system simply finds the event's handler entity and requests event handling, but to handle an area event,
the system has to iterate over different event handlers that are within radius of the event, which is specified in the
\texttt{EventComponent}'s field \texttt{radius} and increases on every update call until the event is destroyed. The system requests
all of the suitable entities to handle the event until any one entity returns \texttt{true}, in which case it destroys the
\texttt{EventComponent} of the event. The reason for destroying the component and not the entity that represents the event is that
an entity that causes the event often gains the component so that the lifetime of the event is bound to the entity -- e.g. a falling
meteor can have an \texttt{EventComponent} of type \texttt{METEOR\_FALLING} and when the meteor hits the ground, both the meteor and
the event get destroyed since they are one entity.

\subsection{GridSystem}

% TODO
\begin{itemize}
    \item describe the update logic (+freed/unfreed and Grid relation)
    \item talk about grid graphics used for debugging?
    \item explain structure placement
    \item describe alignment checks
\end{itemize}

\subsubsection{Grid}

% TODO
\begin{itemize}
    \item explain its purpose and implementation
    \item mention that it only provides a set of grid related operations
        on a set of IDs it's provided (and assumes those are grid)
    \item mention random node placement and entity distribution
    \item mention free node list for ease (and speed) of access
    \item explain graph creation and linking
    \item explain general usage
\end{itemize}

\subsection{TaskSystem}

% TODO
\begin{itemize}
    \item describe the update logic
    \item talk about busy state, processing tasks and checking if task is complete
    \item probably only forward reference the Lua part? or talk about it right here? !ask PJ!
\end{itemize}

\subsection{WaveSystem}

% TODO
\begin{itemize}
    \item describe states and maybe mention why the State design patter wasn't used (too simple)
    \item describe the update logic of the different states (-> countdown, spawning, chilling)
    \item talk about the spawning mechanism, blueprint vector, spawn nodes
    \item talk about wave entity monitoring and wave ending
    \item talk about the wave table
    \item talk about the wstart and wend callbacks
    \item talk about endless mode
    \item possibly explain how to write a wave? or add that to the scripting part?
\end{itemize}

\subsection{Miscellaneous Systems}

% TODO
\begin{itemize}
    \item here explain in alphabetical order the remaining systems
    \item say why these are not as important (that is, not important to be described) as the others
\end{itemize}

\subsubsection{AISystem}

% TODO
\begin{itemize}
    \item describe the update logic
    \item mention update forcing (in relation to the update period mentioned earlier)
\end{itemize}

\subsubsection{GraphicsSystem}

% TODO
\begin{itemize}
    \item say how it's supposed to maintain all manual graphics logic but atm only does explosions
        (since it's the only manual graphics object)
    \item describe the update logic
\end{itemize}

\subsubsection{HealthSystem}

% TODO
\begin{itemize}
    \item describe the update logic
    \item mention configurable regeneration period
\end{itemize}

\subsubsection{InputSystem}

% TODO
\begin{itemize}
    \item describe the update logic
    \item explain initial purpose and why it's not used atm
\end{itemize}

\subsubsection{ManaSpellSystem}

% TODO
\begin{itemize}
    \item describe the update logic (both mana regen and entity spell casting)
    \item possibly talk about the relationship between player spells and entity spells
\end{itemize}

\subsubsection{MovementSystem}

% TODO
\begin{itemize}
    \item describe the update logic
    \item talk aboud move and checked\_move (and can\_move\_to) and why checked is not used
        but can be from lua (and was intended for 1st person mode)
\end{itemize}

\subsubsection{ProductionSystem}

% TODO
\begin{itemize}
    \item describe the update logic
    \item explain how products are spawned and placed
\end{itemize}

\subsubsection{TimeSystem}

% TODO
\begin{itemize}
    \item describe the update logic (mention the multiple comps updated)
    \item explain time event handling (and use)
    \item explain time event advancements
\end{itemize}

\subsubsection{TriggerSystem}

% TODO
\begin{itemize}
    \item describe the update logic
    \item explain how triggering works and why it works that way (factions)
    \item explain the general trap concept?
\end{itemize}

\section{Helpers}

% TODO
\begin{itemize}
    \item describe what helpers are and how are they used
    \item forward reference the not-singleton status of EntitySystem?
    \item explain why they were created (use in Lua and optionally in C++
        for better code readability)
    \item explain why they are slower than direct component manipulation
    \item explain component-helper relationship
    \item mention the general structure of a helper
    \item maybe talk about why they are namespaces and not classes?
        (+ namespace -> allows static class without any change basically)
\end{itemize}

\section{Script}

% TODO
\begin{itemize}
    \item talk about how it works (it's basically a wrapper facade)
    \item mention lpp::Exception
    \item explain the Lua C API (only informative? add a new section with a tutorial?
        tell the reader to read the Lua Programming Language 3rd edition book?)
    \item maybe go through some of the more complex functions?
\end{itemize}

\section{LuaInterface}

% TODO
\begin{itemize}
    \item talk about why it's needed (Lua needs static)
    \item talk about why it's centralised in one class?
\end{itemize}

\subsection{Initialising the API}

% TODO
\begin{itemize}
    \item explain the C++ function binding process
    \item explain the Lua module hierarchy
    \item explain other aspects besides function binding
\end{itemize}

\subsection{Extending the API}

% TODO
\begin{itemize}
    \item explain the general body of the interface functions (stack, return etc.)
    \item (super) small tutorial on how to add new interface functions
\end{itemize}

\section{GUI}

% TODO
\begin{itemize}
    \item talk about the GUI hierarchy
    \item explain initialization
    \item explain CEGUI button binding? maybe in general CEGUI manipulation?
    \item explain save/load file listing
    \item mention the GUIWindow class, base class of the following GUI windows
    \item explain why it has escape\_pressed handler and does not use CEGUI handlers
        for that (would be needed for all subwindows, too much a hassle - also would
        probably disregard the conditional closing)
\end{itemize}

\subsection{Console}

% TODO
\begin{itemize}
    \item talk about how awesome it is during debugging
    \item explain how execution and printing works (+ the history concept?)
    \item explain why it does not execute lines but multi lines after the execute
        button is pressed
\end{itemize}

\subsection{EntityCreator}

% TODO
\begin{itemize}
    \item mention that currently it is used for entity placement and
        the creation part is supposed to be a graphical way to make entities that
        is not currently in the game
    \item explain how it works
    \item explain how it's used for testing
    \item maybe mention that this is where the registered\_entity from EntitySystem
        is used
\end{itemize}

\subsection{EntityTracker}

% TODO
\begin{itemize}
    \item explain how tracking works
    \item talk about why it's useful
    \item mention the upgrade, exp convert and delete functionality?
\end{itemize}

\subsection{ResearchWindow}

% TODO
\begin{itemize}
    \item explain initialisation, how it works
    \item explain dummy\_unlock and its relationship with serialization
\end{itemize}

\subsection{Miscellaneous Windows}

% TODO
\begin{itemize}
    \item say that these are generally not that complex and quite straight forward
\end{itemize}

\subsubsection{BuilderWindow}

% TODO
\begin{itemize}
    \item talk about building registration (how it relates to unlocking)
    \item talk about the assembly line (also used in spell casting window)
        and why it's good (lack of images -> buttons need to be big and readable)
    \item don't forget to mention that this is just a graphical front end
        to EntityPlacer (with price management etc.) as is EntityCreator (though
        that one ignores price, and has all unlocked even enemies)
\end{itemize}

\subsubsection{GameLog}

% TODO
\begin{itemize}
    \item just mention that it is basically the ingame chat posting info
        for the player
    \item also maybe again mention history (same as console)?
\end{itemize}

\subsubsection{MessageToPlayerWindow}

% TODO
\begin{itemize}
    \item talk about button renaming and action assignment
    \item then mention how to use this as a whole
\end{itemize}

\subsubsection{OptionsWindow}

% TODO
\begin{itemize}
    \item talk about actions, key bindings and video settings
        (+ how they are done?)
\end{itemize}

\subsubsection{SpellCastingWindow}

% TODO
\begin{itemize}
    \item talk about spell registration (how it relates to unlocking)
    \item just mention the assembly line (already explained in BuilderWindow)
    \item talk about the relationship with the SpellCaster and how spell casting
        works on this side (simple invoking of the spell caster and marking
        the spell as active if needed)
    \item don't forget to mention that this is just a graphical front end
        to SpellCaster basically
\end{itemize}

\subsubsection{TopBar}

% TODO
\begin{itemize}
    \item just say something about its purpose (monitoring of resources)
\end{itemize}

\section{SpellCaster}

% TODO
\begin{itemize}
    \item discuss the spell casting concept in the game
    \item mention the spell types
    \item explain why it's so damn cool (ease of spell creation, run time spell creation)
    \item forward reference the Lua spell structure, which is explained later in Scripting
\end{itemize}

\section{Utilities}

% TODO
\begin{itemize}
    \item just say that these are classes that are not directly part of
        the game world but are used as background tools that support the game
\end{itemize}

\subsection{Camera}

% TODO
\begin{itemize}
    \item talk about how it allows free/nonfree mode, resetting
        and backups
    \item maybe talk more about the free nonfree mode and how to toggle them
        (both keybind and command)
\end{itemize}

\subsection{Effects}

% TODO
\begin{itemize}
    \item talk about how awesome they are and allowed the creation of
        extensible effect application framework in CombatSystem
    \item explain how to write one
    \item mention that they are used as template arguments and as such
        should conform the given interface (also explain that)
    \item maybe ilustrate their structure on one of them
\end{itemize}

\subsection{EntityPlacer}

% TODO
\begin{itemize}
    \item explain its purpose and how it works
    \item explain why only the graphics component data is used (so it's ignored
        by the game world and serializer, etc.)
\end{itemize}

\subsection{LevelGenerator}

% TODO
\begin{itemize}
    \item explain their purpose and how to write one
    \item mention the cycle count constructor parameter
    \item mention the default tables in config (and that it's easy to add new ones)
\end{itemize}

\subsubsection{RandomLevelGenerator}

% TODO
\begin{itemize}
    \item say that this is just naive algorithm for a pseudo random level generation
        using number of neighbours that are gold deposits to determine if a gold
        deposit should be spawned
\end{itemize}

\subsection{RayCaster}

% TODO
\begin{itemize}
    \item explain that I'm a noob that stole other programmer's idea for this
        from the Ogre wiki
    \item explain why it's needed (polygon precision ray casting -> half cubes,
        without it only bounding boxes are checked and free space is impenetrable)
\end{itemize}

\subsection{SelectionBox}

% TODO
\begin{itemize}
    \item explain its purpose and how it works
    \item talk about single/area selection and multi selection using shift
\end{itemize}

\section{Pathfinding}

% TODO
\begin{itemize}
    \item recapitulate form analysis that a modifiable function was used
        that allows different algorithms, heuristics and path types
    \item mentions its parameters (destruction, add path are primary!)
    \item mention how destruction works
    \item mentions why path addition is optional (for checks)
\end{itemize}

\subsection{Algorithms}

% TODO
\begin{itemize}
    \item explain how they should be implemented (what functions, as they
        are used as template parameters)
    \item mention that A* is the only currently implemented
    \item mention portal implementation
    \item mention difference in complexity (component lookups)
    \item mention any other differences from a general A*
\end{itemize}

\subsection{Heuristics}

% TODO
\begin{itemize}
    \item explain how they are used and why they are inheriting a base class
        while other functors are not (state needed for some -> run away heuristic)
    \item maybe demonstrate on an example as the code is small?
\end{itemize}

\subsection{Path Types}

% TODO
\begin{itemize}
    \item explain what these things are and when they are used to check
        if the algorithm should stop
    \item explain their effect on the A* algorithm
\end{itemize}

\section{Serialization}

% TODO
\begin{itemize}
    \item talk about how easy component serialization is and how
        to create template specializations for new components
    \item show an example?
    \item explain the whole saving process, ents to be destroyed, unlocks,
        player, grid etc.
    \item explain the loading process
\end{itemize}

\section{Player}

% TODO
\begin{itemize}
    \item just say that it is used as a resource bank, keeping track
        of gold, mana, units etc
    \item mention that it also holds the starting unlocks used for new games
        (saved there during the game initialisation)
\end{itemize}

\section{Singleton Design Pattern}

% TODO
\begin{itemize}
    \item explain what this stuff is, its pros \& cons
    \item mention that the main reason for its use in this game
        is having one instance, not that much global access
\end{itemize}

\subsubsection{Script}

% TODO
\begin{itemize}
    \item mention how two Lua virtual machines cannot communicate
        and data are bound to C++ (via EntitySystem) so it's completely
        unnecessary to have more than one Scripting engine
\end{itemize}

\subsubsection{GUI}

% TODO
\begin{itemize}
    \item why would we want to have two GUIs?
    \item mention that here is the global access very good for testing?
\end{itemize}

\subsubsection{Player}

% TODO
\begin{itemize}
    \item why would we want two sets of player resources?
    \item serialization preserves them and shown is only the main set
        (also used is only the main one)
\end{itemize}

\subsubsection{Grid}

% TODO
\begin{itemize}
    \item explains how it only operates on a set of given IDs that are
        made during graph creation (+ mentions it would be easy to implement
        their switch) so there does not need to be more than one pathfinding grid
    \item also mention that due to the nature of the game levels, it would be nonsense
        to have two grids
\end{itemize}

\subsubsection{EntitySystem}

% TODO
\begin{itemize}
    \item explain how even though it's getting passed around a lot (mainly Helpers),
        there could be a reason to use more than one EntitySystem instance (like a backup
        for example) and thus the Singleton pattern might not be the best choice
    \item maybe compare it to the 4 previous classes
\end{itemize}

\section{Extending the Game}

% TODO
\begin{itemize}
    \item small sequence of tasks that are needed for a new feature addition
        (that is component, system etc.)
    \item idea: show how a TargetedComponent would be implemented, allowing
        handlers for targeting/untargeting and how this could be used to create
        a chess mod
\end{itemize}
